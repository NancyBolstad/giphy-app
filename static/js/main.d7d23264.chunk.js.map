{"version":3,"sources":["util/constants.ts","util/giphyService.ts","components/TrendingSearch/index.tsx","util/icons.tsx","components/Button/index.tsx","components/GiphySearch/index.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["GIPHY_API_KEY","PAGE_SIZE","a","searchEndpoint","searchTerm","offset","url","fetch","response","json","data","giphyService","Gif","styled","img","TrendingSearch","React","trendingImages","setTrendingImages","giphyResponse","console","log","Array","isArray","length","useGiphyService","map","element","src","images","downsized","alt","title","searchIcon","viewBox","d","Button","props","variant","css","DumbButton","withComponent","SearchSectionWrapper","div","SearchBlockWrapper","SearchFormWrapper","ResultWrapper","Status","GiphySearch","searchValue","setSearchValue","isLoading","setIsLoading","didntFind","setDidntFind","total","setTotal","hasSearched","setHasSearched","searchResult","setSearchResult","moreContent","setMoreContent","paginationPosition","setPaginationPosition","handleSearchSubmit","e","preventDefault","searchImages","finding","pagination","total_count","newImages","onSubmit","id","className","type","aria-label","placeholder","value","onChange","target","onClick","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d7d23264.chunk.js","sourcesContent":["export const GIPHY_API_KEY = 'Fr2FLf1hX0ilg377EgI3B09onAkkngUB';\nexport const PAGE_SIZE = 35;\nexport const GIPHY_ENDPOINT = 'https://api.giphy.com/v1/gifs/';\n","import { Root } from '../types/apiData';\nimport { PAGE_SIZE, GIPHY_API_KEY } from './constants';\n\ninterface giphyServiceProps {\n  searchEndpoint?: string;\n  searchTerm?: string;\n  offset?: number;\n}\n\nasync function giphyService({ searchEndpoint, searchTerm, offset }: giphyServiceProps) {\n  const url = `https://api.giphy.com/v1/gifs/${\n    searchEndpoint ? searchEndpoint : 'trending'\n  }?api_key=${GIPHY_API_KEY}&q=${searchTerm}&limit=${PAGE_SIZE}&offset=${\n    offset ? offset : 0\n  }&rating=G&lang=en`;\n\n  try {\n    const response = await fetch(url);\n    const data: Root = await response.json();\n\n    return data;\n  } catch (err) {\n    throw err;\n  }\n}\n\nexport default giphyService;\n","import * as React from 'react';\nimport styled from 'styled-components';\nimport Columned from 'react-columned';\nimport { Root, GifObj } from '../../types/apiData';\nimport giphyService from '../../util/giphyService';\n\ninterface ITrendingSearchProps {}\n\nconst Gif = styled.img`\n  display: block;\n  width: 100%;\n  margin: 0.3rem;\n`;\n\nexport const TrendingSearch: React.FunctionComponent<ITrendingSearchProps> = () => {\n  const [trendingImages, setTrendingImages] = React.useState<GifObj[]>([]);\n\n  async function useGiphyService() {\n    const giphyResponse: Root = await giphyService({});\n\n    console.log(11111);\n\n    if (Array.isArray(giphyResponse.data) && giphyResponse.data.length > 0) {\n      setTrendingImages(giphyResponse.data);\n    } else {\n      setTrendingImages([]);\n    }\n  }\n\n  useGiphyService();\n\n  return (\n    <Columned>\n      {trendingImages &&\n        trendingImages.map(element => (\n          <Gif src={element.images.downsized.url} alt={element.title}></Gif>\n        ))}\n    </Columned>\n  );\n};\n\nexport default TrendingSearch;\n","import * as React from 'react';\n\nexport const searchIcon = (\n  <svg viewBox=\"0 0 56.966 56.966\">\n    <path\n      d=\"M55.146,51.887L41.588,37.786c3.486-4.144,5.396-9.358,5.396-14.786c0-12.682-10.318-23-23-23s-23,10.318-23,23\n\ts10.318,23,23,23c4.761,0,9.298-1.436,13.177-4.162l13.661,14.208c0.571,0.593,1.339,0.92,2.162,0.92\n\tc0.779,0,1.518-0.297,2.079-0.837C56.255,54.982,56.293,53.08,55.146,51.887z M23.984,6c9.374,0,17,7.626,17,17s-7.626,17-17,17\n\ts-17-7.626-17-17S14.61,6,23.984,6z\"\n    />\n  </svg>\n);\n","import styled, { css } from 'styled-components';\n\ninterface Props {\n  variant?: 'submit' | 'loadMore';\n  buttonColor?: 'red' | 'transparent';\n}\n\nconst Button = styled.a<Props>`\n  display: table-cell;\n  text-decoration: none;\n  cursor: pointer;\n  color: #ffffff;\n  text-align: center;\n  vertical-align: middle;\n  text-transform: capitalize;\n  font-weight: bold;\n  margin: 2rem auto;\n\n  ${props =>\n    props.variant === 'loadMore' &&\n    css`\n      height: 3.35rem;\n      font-size: 1.5rem;\n      border: 2px solid #ffffff;\n      background-color: black;\n      color: #ffffff;\n      width: 12rem;\n\n      &:hover {\n        background: #09ebaf;\n        transition: background 400ms ease-in-out;\n        border: none;\n        color: black;\n      }\n\n      &:active {\n        opacity: 0.7;\n        box-shadow: none;\n      }\n    `};\n\n  &:focus {\n    outline: none;\n  }\n`;\n\nconst DumbButton = Button.withComponent('button');\n\nexport default Button;\nexport { DumbButton };\n","import * as React from 'react';\nimport styled from 'styled-components';\nimport Columned from 'react-columned';\nimport TrendingSearch from '../TrendingSearch';\nimport { GifObj } from '../../types/apiData';\nimport giphyService from '../../util/giphyService';\nimport { PAGE_SIZE } from '../../util/constants';\nimport { searchIcon } from '../../util/icons';\nimport { DumbButton } from '../Button';\n\ninterface ISearchProps {}\n\nconst SearchSectionWrapper = styled.div`\n  display: flex;\n  background-color: #000000;\n  color: #ffffff;\n  flex-direction: column;\n  width: 85vw;\n  margin: 0 auto;\n\n  h1 {\n    margin: 2rem auto;\n    font-size: 2.2rem;\n  }\n`;\n\nconst SearchBlockWrapper = styled.div`\n  padding-bottom: 3rem;\n  width: 80vw;\n  margin: 0 auto;\n`;\n\nconst SearchFormWrapper = styled.div`\n  form {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n    margin: 0 auto;\n    width: 80vw;\n    box-shadow: 10px 10px 5px 0px #0002f1;\n\n    @media screen and (min-width: 768px) {\n      width: 60vw;\n    }\n\n    @media screen and (min-width: 1080px) {\n      width: 52vw;\n    }\n  }\n\n  input[type='text'] {\n    border: none;\n    background: #e9e9e9;\n    white-space: nowrap;\n    padding: 0.55rem 0.75rem;\n    border: none;\n    font-size: 1.1em;\n    text-decoration: none;\n    line-height: normal;\n    height: 2rem;\n    flex-grow: 1;\n    width: 40vw;\n  }\n\n  button[type='submit'] {\n    background-color: #09ebaf;\n    color: black;\n    border: none;\n    cursor: pointer;\n    flex-grow: 1;\n    width: 10vw;\n\n    svg {\n      height: 1.5rem;\n      width: 1.5rem;\n      fill: black;\n    }\n\n    @media screen and (min-width: 1080px) {\n      width: 3rem;\n    }\n  }\n\n  input[type='text']:focus {\n    background: #ffffff;\n    outline: none;\n    border: 2px solid #09ebaf;\n  }\n\n  button[type='submit']:focus {\n    outline: none;\n  }\n  button[type='submit']:hover {\n    opacity: 0.7;\n  }\n`;\n\nconst ResultWrapper = styled.div`\n  padding: 30px;\n`;\n\nconst Status = styled.div`\n  text-align: center;\n  margin-bottom: 3rem;\n  font-size: 1.375rem;\n  font-weight: bold;\n  color: #ffd635;\n  animation: pop-in 0.6s ease-out forwards;\n\n  @keyframes pop-in {\n    0% {\n      opacity: 0;\n      transform: translateY(-4rem) scale(0.8);\n    }\n    100% {\n      opacity: 1;\n      transform: none;\n    }\n  }\n`;\n\nconst Gif = styled.img`\n  display: block;\n  width: 100%;\n  margin: 0.3rem;\n`;\n\nexport const GiphySearch: React.FunctionComponent<ISearchProps> = () => {\n  const [searchValue, setSearchValue] = React.useState('');\n  const [isLoading, setIsLoading] = React.useState(false);\n  const [didntFind, setDidntFind] = React.useState(false);\n  const [total, setTotal] = React.useState(0);\n  const [hasSearched, setHasSearched] = React.useState(false);\n  const [searchResult, setSearchResult] = React.useState<GifObj[]>([]);\n  const [moreContent, setMoreContent] = React.useState(false);\n  const [paginationPosition, setPaginationPosition] = React.useState(0);\n\n  const handleSearchSubmit = async (e: any) => {\n    e.preventDefault();\n    setHasSearched(true);\n    setSearchResult([]);\n    setIsLoading(true);\n    searchImages();\n  };\n\n  async function searchImages() {\n    const finding = await giphyService({\n      searchEndpoint: 'search',\n      searchTerm: searchValue,\n      offset: paginationPosition,\n    });\n    const { data, pagination } = finding;\n\n    if (Array.isArray(data) && data.length > 0) {\n      setSearchResult(data);\n      setHasSearched(true);\n      setDidntFind(false);\n      setTotal(pagination.total_count);\n      setPaginationPosition(paginationPosition + PAGE_SIZE);\n    } else {\n      setDidntFind(true);\n      setSearchResult([]);\n    }\n\n    if (searchResult.length < pagination.total_count) {\n      setMoreContent(true);\n    }\n\n    setIsLoading(false);\n  }\n\n  async function getMoreImages() {\n    const newImages = await giphyService({\n      searchEndpoint: 'search',\n      searchTerm: searchValue,\n      offset: paginationPosition,\n    });\n    const { data, pagination } = newImages;\n\n    if (newImages.data.length > 0) {\n      setHasSearched(true);\n      setSearchResult([...searchResult, ...data]);\n      setPaginationPosition(paginationPosition + PAGE_SIZE);\n    } else {\n      setDidntFind(true);\n      setMoreContent(false);\n      setSearchResult([]);\n    }\n\n    if (searchResult.length < pagination.total_count) {\n      setMoreContent(true);\n    }\n\n    setIsLoading(false);\n  }\n\n  return (\n    <SearchSectionWrapper>\n      <h1>Giphy Search</h1>\n      <SearchBlockWrapper>\n        <SearchFormWrapper>\n          <form onSubmit={handleSearchSubmit}>\n            <input\n              id=\"searchForm\"\n              className=\"searchInput\"\n              type=\"text\"\n              aria-label=\"Search gif\"\n              placeholder=\"Search for gifs\"\n              value={searchValue}\n              onChange={(e: any) => {\n                e.preventDefault();\n                setSearchValue(e.target.value);\n              }}\n            />\n            <button type=\"submit\" aria-label=\"Search for gifs\">\n              {searchIcon}\n            </button>\n          </form>\n        </SearchFormWrapper>\n      </SearchBlockWrapper>\n      {!hasSearched && <TrendingSearch></TrendingSearch>}\n      {hasSearched && (\n        <ResultWrapper>\n          {isLoading && <Status>Loading…</Status>}\n          {didntFind && <Status>{`No results for ${searchValue}`}</Status>}\n          {!didntFind && <Status>{`Found ${total} gifts!`}</Status>}\n          {searchResult && (\n            <Columned>\n              {searchResult.map(element => (\n                <Gif src={element.images.downsized.url} alt={element.title}></Gif>\n              ))}\n            </Columned>\n          )}\n        </ResultWrapper>\n      )}\n      {moreContent && !didntFind && (\n        <DumbButton variant=\"loadMore\" onClick={getMoreImages} title=\"Load more images\">\n          Load More\n        </DumbButton>\n      )}\n    </SearchSectionWrapper>\n  );\n};\n\nexport default GiphySearch;\n","import React from 'react';\nimport './App.css';\nimport { GiphySearch } from './components/GiphySearch';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <GiphySearch />\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}